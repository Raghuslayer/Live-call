<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VideoCall Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .auth-container, .callid-container, .call-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 40px;
            width: 100%;
            max-width: 1200px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            text-align: center;
            display: none;
        }

        .active {
            display: block;
        }

        h2 {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        input {
            width: 100%;
            padding: 12px;
            border-radius: 25px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 16px;
        }

        input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        button:active {
            transform: scale(0.95);
        }

        .toggle-link {
            color: #a1c4fd;
            cursor: pointer;
            text-decoration: underline;
            margin-top: 10px;
            display: inline-block;
        }

        .status {
            margin-top: 20px;
            min-height: 24px;
            color: #ff4d4d;
        }

        .video-container {
            display: flex;
            gap: 20px;
            margin-top: 40px;
        }

        .video-box {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        video {
            width: 100%;
            border-radius: 10px;
            transform: scaleX(-1);
            max-height: 400px;
            object-fit: cover;
        }

        .placeholder {
            text-align: center;
            color: rgba(255, 255, 255, 0.7);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .code-section {
            text-align: center;
            margin-top: 40px;
        }

        .call-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            animation: popIn 0.3s ease;
            z-index: 100;
        }

        .call-alert button {
            margin: 10px;
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.5); }
            to { transform: translate(-50%, -50%) scale(1); }
        }

        @media (max-width: 768px) {
            .auth-container, .callid-container, .call-container {
                padding: 20px;
            }

            .video-container {
                flex-direction: column;
                gap: 10px;
            }

            .video-box {
                min-height: 200px;
                max-height: 300px;
                width: 100%;
            }

            video {
                max-height: 250px;
            }

            .local-video-box {
                order: 1;
            }

            .remote-video-box {
                order: 2;
            }

            .controls {
                gap: 10px;
                padding: 10px;
                justify-content: center;
            }

            button {
                padding: 10px 20px;
                font-size: 14px;
            }

            input {
                width: 80%;
                max-width: 250px;
            }
        }

        @media (min-width: 769px) {
            .video-container {
                flex-direction: row;
            }
        }
    </style>
</head>
<body>
    <div class="auth-container" id="authContainer">
        <h2 id="formTitle">Login</h2>
        <div class="form-group">
            <input type="email" id="email" placeholder="Email" required>
        </div>
        <div class="form-group">
            <input type="password" id="password" placeholder="Password" required>
        </div>
        <button id="authButton" onclick="handleAuth()">Login</button>
        <div class="toggle-link" onclick="toggleForm()">Don't have an account? Sign Up</div>
        <div class="status" id="authStatus"></div>
    </div>

    <div class="callid-container" id="callIdContainer">
        <h2>Create Your Call ID</h2>
        <div class="form-group">
            <input type="text" id="callIdInput" placeholder="Enter unique Call ID (e.g., raghu123)" required>
        </div>
        <button onclick="saveCallId()">Save Call ID</button>
        <div class="status" id="callIdStatus"></div>
    </div>

    <div class="call-container" id="callContainer">
        <div class="code-section">
            <h2>Your Call ID: <span id="myCallId"></span></h2>
            <button onclick="signOut()">Sign Out</button>
            <input type="text" id="targetCallId" placeholder="Enter Call ID to call">
            <button onclick="startCall()">Call</button>
            <div class="status" id="callStatus"></div>
        </div>

        <div class="video-container">
            <div class="video-box local-video-box">
                <video id="localVideo" autoplay muted></video>
                <div id="localPlaceholder" class="placeholder">Your camera will appear here</div>
            </div>
            <div class="video-box remote-video-box">
                <video id="remoteVideo" autoplay></video>
                <div id="remotePlaceholder" class="placeholder">Waiting for connection...</div>
            </div>
        </div>

        <div class="controls">
            <button id="toggleCam" onclick="toggleCamera()">Camera Off</button>
            <button id="toggleMic" onclick="toggleMic()">Mic Off</button>
            <button id="endCall" onclick="endCall()" style="display: none; background: #ff4d4d;">End Call</button>
        </div>

        <div id="incomingCallAlert" class="call-alert" style="display: none;">
            <h2>Incoming Call from <span id="callerId"></span></h2>
            <button onclick="acceptCall()">Accept</button>
            <button onclick="rejectCall()" style="background: #ff4d4d;">Reject</button>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyAyBQ5XefqnuXOj6tdYlFiied5sVFoOE40",
            authDomain: "live-call-33ea7.firebaseapp.com",
            projectId: "live-call-33ea7",
            storageBucket: "live-call-33ea7.firebasestorage.app",
            messagingSenderId: "518167322129",
            appId: "1:518167322129:web:caf131eb4c4bec2272dbb0"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        firebase.firestore.setLogLevel('debug');

        const authContainer = document.getElementById('authContainer');
        const callIdContainer = document.getElementById('callIdContainer');
        const callContainer = document.getElementById('callContainer');
        const formTitle = document.getElementById('formTitle');
        const authButton = document.getElementById('authButton');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');
        const authStatus = document.getElementById('authStatus');
        const callIdInput = document.getElementById('callIdInput');
        const callIdStatus = document.getElementById('callIdStatus');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const localPlaceholder = document.getElementById('localPlaceholder');
        const remotePlaceholder = document.getElementById('remotePlaceholder');
        const callStatus = document.getElementById('callStatus');
        const incomingCallAlert = document.getElementById('incomingCallAlert');
        const callerIdSpan = document.getElementById('callerId');
        const endCallBtn = document.getElementById('endCall');
        const myCallIdSpan = document.getElementById('myCallId');

        let isLogin = true;
        let localStream;
        let remoteStream;
        let peerConnection;
        let myCallId;
        let targetCallId;
        let callerCallId;
        let isCaller = false;
        let callDoc;
        let callListeners = [];
        let isMediaStreamInitialized = false;

        function showSection(section) {
            console.log(`Showing section: ${section.id}`);
            authContainer.classList.remove('active');
            callIdContainer.classList.remove('active');
            callContainer.classList.remove('active');
            section.classList.add('active');
            section.offsetHeight;
        }

        function toggleForm() {
            isLogin = !isLogin;
            formTitle.textContent = isLogin ? 'Login' : 'Sign Up';
            authButton.textContent = isLogin ? 'Login' : 'Sign Up';
            authStatus.textContent = '';
            document.querySelector('.toggle-link').textContent = isLogin ? "Don't have an account? Sign Up" : 'Already have an account? Login';
        }

        async function handleAuth() {
            const email = emailInput.value.trim();
            const password = passwordInput.value.trim();
            authStatus.textContent = '';

            if (!email || !password) {
                authStatus.textContent = 'Please enter email and password';
                return;
            }

            try {
                if (isLogin) {
                    console.log('Attempting login with:', email);
                    await auth.signInWithEmailAndPassword(email, password);
                    console.log('Login successful');
                    authStatus.textContent = 'Login successful, loading...';
                } else {
                    console.log('Attempting signup with:', email);
                    await auth.createUserWithEmailAndPassword(email, password);
                    console.log('Signup successful, showing call ID creation');
                    showSection(callIdContainer);
                    authStatus.textContent = '';
                }
            } catch (error) {
                console.error('Auth error:', error.message);
                authStatus.textContent = error.message;
            }
        }

        async function saveCallId() {
            const callId = callIdInput.value.trim();
            callIdStatus.textContent = '';

            if (!callId || callId.length < 4) {
                callIdStatus.textContent = 'Call ID must be at least 4 characters';
                return;
            }

            try {
                const callIdDoc = await db.collection('callIds').doc(callId).get();
                if (callIdDoc.exists) {
                    callIdStatus.textContent = 'Call ID already taken, please choose another';
                    return;
                }

                const user = auth.currentUser;
                await retryFirestoreOperation(() =>
                    db.collection('users').doc(user.uid).set({
                        callId: callId,
                        online: true,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true })
                );

                await retryFirestoreOperation(() =>
                    db.collection('callIds').doc(callId).set({ uid: user.uid })
                );
                console.log(`CallId ${callId} saved, initializing call section`);
                myCallId = callId;
                await initCallSection();
                showSection(callContainer);
            } catch (error) {
                console.error('Error saving callId:', error);
                callIdStatus.textContent = error.message;
            }
        }

        async function signOut() {
            try {
                await auth.signOut();
                console.log('Signed out, showing auth section');
                await resetCallState();
                showSection(authContainer);
                authStatus.textContent = 'Signed out successfully';
            } catch (error) {
                console.error('Sign out error:', error);
                callStatus.textContent = 'Error signing out';
            }
        }

        async function resetCallState() {
            console.log('Resetting call state');
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }
            remoteVideo.srcObject = null;
            remotePlaceholder.style.display = 'block';
            remoteVideo.style.display = 'none';
            endCallBtn.style.display = 'none';
            incomingCallAlert.style.display = 'none';
            targetCallId = null;
            callerCallId = null;
            isCaller = false;
            callDoc = null;
            callListeners.forEach(unsubscribe => unsubscribe());
            callListeners = [];
            callStatus.textContent = '';

            // Only reinitialize localStream if not in the middle of starting a call
            if (!isCaller && !targetCallId) {
                try {
                    await initMediaStream();
                    console.log('Local stream reinitialized after reset');
                } catch (error) {
                    console.error('Error reinitializing local stream:', error);
                    callStatus.textContent = 'Failed to reinitialize camera/microphone';
                }
            }
        }

        async function initMediaStream() {
            if (isMediaStreamInitialized && localStream?.active) {
                console.log('Media stream already initialized and active');
                return true;
            }

            try {
                console.log('Initializing media stream');
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                localPlaceholder.style.display = 'none';
                localVideo.style.display = 'block';
                isMediaStreamInitialized = true;
                console.log('Media stream initialized:', localStream.getTracks());
                return true;
            } catch (error) {
                console.error('Error initializing media stream:', error);
                callStatus.textContent = 'Could not access camera/microphone. Please grant permissions or check device availability.';
                isMediaStreamInitialized = false;
                return false;
            }
        }

        async function initCallSection() {
            try {
                console.log('Initializing call section for callId:', myCallId);
                myCallIdSpan.textContent = myCallId;

                await retryFirestoreOperation(() =>
                    db.collection('users').doc(auth.currentUser.uid).set({
                        online: true,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true })
                );

                await cleanupOldCalls();

                const callListener = db.collection('users').doc(auth.currentUser.uid).collection('calls').onSnapshot(snapshot => {
                    console.log('Call listener triggered, changes:', snapshot.docChanges().length);
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added' || change.type === 'modified') {
                            const callData = change.doc.data();
                            console.log('Received call update:', callData, 'Doc ID:', change.doc.id);
                            handleIncomingCall(callData, change.doc.id);
                        }
                    });
                }, error => {
                    console.error('Call listener error:', error);
                    callStatus.textContent = 'Error listening for calls: ' + error.message;
                });
                callListeners.push(callListener);

                const mediaSuccess = await initMediaStream();
                if (!mediaSuccess) {
                    callStatus.textContent = 'Media initialization failed. Please grant permissions and refresh.';
                }
            } catch (error) {
                console.error('Error initializing call section:', error);
                callStatus.textContent = 'Error loading call data. Please sign out and try again.';
            }
        }

        async function cleanupOldCalls() {
            try {
                const user = auth.currentUser;
                const calls = await retryFirestoreOperation(() =>
                    db.collection('users').doc(user.uid).collection('calls').get()
                );
                for (const doc of calls.docs) {
                    await retryFirestoreOperation(() => doc.ref.delete());
                    console.log('Deleted call document:', doc.id);
                }
            } catch (error) {
                console.error('Error cleaning up old calls:', error);
            }
        }

        async function retryFirestoreOperation(operation, maxAttempts = 3, delay = 1000) {
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    return await operation();
                } catch (error) {
                    console.error(`Firestore operation failed (attempt ${attempt}/${maxAttempts}):`, error);
                    if (attempt === maxAttempts) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        function handleIncomingCall(callData, callDocId) {
            console.log('Handling incoming call:', callData, 'Doc ID:', callDocId);
            if (callData.status === 'calling') {
                const now = new Date();
                const callTime = callData.timestamp?.toDate();
                if (callTime && (now - callTime > 60000)) {
                    console.log('Ignoring stale call:', callDocId);
                    retryFirestoreOperation(() =>
                        db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete()
                    );
                    return;
                }
                callerCallId = callData.caller;
                if (!callerCallId) {
                    console.error('Caller ID is missing in call data:', callData);
                    callStatus.textContent = 'Invalid call: Caller ID missing';
                    retryFirestoreOperation(() =>
                        db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete()
                    );
                    return;
                }
                callerIdSpan.textContent = callerCallId;
                incomingCallAlert.style.display = 'block';
                callStatus.textContent = `Incoming call from ${callerCallId}`;
                incomingCallAlert.dataset.callDocId = callDocId;
            } else {
                incomingCallAlert.style.display = 'none';
                if (callData.status === 'ended' && (peerConnection || localStream)) {
                    console.log('Call ended by other party, resetting state');
                    endCall();
                } else {
                    callStatus.textContent = callData.status === 'rejected' ? 'Call was rejected' : 
                                            callData.status === 'answered' ? `Call connected with ${callerCallId || 'unknown'}` : 
                                            callData.status === 'completed' ? 'Call completed' : '';
                    if (callStatus.textContent) {
                        setTimeout(() => callStatus.textContent = '', 3000);
                    }
                }
                retryFirestoreOperation(() =>
                    db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete()
                );
            }
        }

        async function startCall() {
            console.log('Starting call, ensuring media stream is initialized');
            const mediaSuccess = await initMediaStream();
            if (!mediaSuccess) {
                callStatus.textContent = 'Failed to access camera/microphone';
                return;
            }

            targetCallId = document.getElementById('targetCallId').value.trim();
            if (!targetCallId) {
                callStatus.textContent = 'Please enter a Call ID to call';
                return;
            }
            if (targetCallId === myCallId) {
                callStatus.textContent = "You can't call yourself";
                return;
            }

            callStatus.textContent = `Calling ${targetCallId}...`;
            isCaller = true;

            try {
                const targetCallIdDoc = await retryFirestoreOperation(() =>
                    db.collection('callIds').doc(targetCallId).get()
                );
                if (!targetCallIdDoc.exists) {
                    callStatus.textContent = 'Call ID not found';
                    return;
                }

                const targetUid = targetCallIdDoc.data().uid;
                await createPeerConnection();

                callDoc = db.collection('calls').doc();
                const offerCandidates = callDoc.collection('offerCandidates');
                const answerCandidates = callDoc.collection('answerCandidates');

                const callData = {
                    caller: myCallId,
                    callId: callDoc.id,
                    status: 'calling',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                };
                console.log('Attempting to write call notification:', callData);
                await retryFirestoreOperation(() =>
                    db.collection('users').doc(targetUid).collection('calls').doc(callDoc.id).set(callData)
                );
                console.log(`Call notification written to target user: ${targetUid}, callId: ${callDoc.id}`);

                const offerDescription = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offerDescription);

                const offer = {
                    sdp: offerDescription.sdp,
                    type: offerDescription.type,
                    caller: myCallId,
                    callee: targetCallId
                };

                await retryFirestoreOperation(() => callDoc.set({ offer }));
                console.log('Offer written to call document:', offer);

                const callSnapshotListener = callDoc.onSnapshot(async snapshot => {
                    const data = snapshot.data();
                    console.log('Call snapshot update:', data);
                    if (!peerConnection.currentRemoteDescription && data?.answer) {
                        const answerDescription = new RTCSessionDescription(data.answer);
                        await peerConnection.setRemoteDescription(answerDescription);
                        callStatus.textContent = `Connected with ${targetCallId}`;
                        endCallBtn.style.display = 'block';
                    }
                    if (data?.status === 'ended') {
                        console.log('Call ended by other party');
                        endCall();
                    }
                }, error => {
                    console.error('Call snapshot listener error:', error);
                });
                callListeners.push(callSnapshotListener);

                const answerCandidatesListener = answerCandidates.onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(async change => {
                        if (change.type === 'added') {
                            console.log('Received answer candidate:', change.doc.data());
                            const candidate = new RTCIceCandidate(change.doc.data());
                            await peerConnection.addIceCandidate(candidate).catch(error => {
                                console.error('Error adding ICE candidate:', error);
                            });
                        }
                    });
                }, error => {
                    console.error('Answer candidates listener error:', error);
                });
                callListeners.push(answerCandidatesListener);

                peerConnection.onicecandidate = async event => {
                    if (event.candidate) {
                        console.log('Sending ICE candidate:', event.candidate);
                        await retryFirestoreOperation(() =>
                            offerCandidates.add(event.candidate.toJSON())
                        );
                    }
                };

                setTimeout(() => {
                    if (!peerConnection.currentRemoteDescription) {
                        callStatus.textContent = 'Call timed out';
                        endCall();
                    }
                }, 30000);
            } catch (error) {
                console.error('Error starting call:', error);
                callStatus.textContent = 'Error starting call: ' + error.message;
                await resetCallState();
            }
        }

        async function acceptCall() {
            console.log('Accepting call, ensuring media stream is initialized');
            const mediaSuccess = await initMediaStream();
            if (!mediaSuccess) {
                incomingCallAlert.style.display = 'none';
                callStatus.textContent = 'Failed to access camera/microphone';
                return;
            }

            incomingCallAlert.style.display = 'none';
            callStatus.textContent = `Connecting with ${callerCallId}...`;

            try {
                await createPeerConnection();

                const user = auth.currentUser;
                const callDocId = incomingCallAlert.dataset.callDocId;
                console.log('Attempting to accept call with doc ID:', callDocId);

                const callDocRef = db.collection('users').doc(user.uid).collection('calls').doc(callDocId);
                const callDocSnap = await retryFirestoreOperation(() => callDocRef.get());

                if (!callDocSnap.exists) {
                    console.error('Call document not found:', callDocId);
                    callStatus.textContent = 'Call no longer exists';
                    await retryFirestoreOperation(() => callDocRef.delete());
                    return;
                }

                const callData = callDocSnap.data();
                console.log('Call data retrieved:', callData);

                callDoc = db.collection('calls').doc(callData.callId);
                const offerCandidates = callDoc.collection('offerCandidates');
                const answerCandidates = callDoc.collection('answerCandidates');

                await retryFirestoreOperation(() =>
                    callDocRef.update({
                        status: 'answered',
                        answeredAt: firebase.firestore.FieldValue.serverTimestamp()
                    })
                );
                console.log('Call marked as answered');

                const callSnapshotListener = callDoc.onSnapshot(async snapshot => {
                    const data = snapshot.data();
                    console.log('Call document snapshot:', data);
                    if (!peerConnection.currentRemoteDescription && data?.offer) {
                        console.log('Processing offer SDP:', data.offer);
                        const offerDescription = new RTCSessionDescription(data.offer);
                        await peerConnection.setRemoteDescription(offerDescription);

                        const answerDescription = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answerDescription);

                        const answer = {
                            type: answerDescription.type,
                            sdp: answerDescription.sdp
                        };

                        await retryFirestoreOperation(() => callDoc.update({ answer }));
                        console.log('Answer sent to call document:', answer);

                        callStatus.textContent = `Connected with ${callerCallId}`;
                        endCallBtn.style.display = 'block';

                        await retryFirestoreOperation(() => callDocRef.delete());
                        console.log('Call notification deleted after connection');
                    }
                    if (data?.status === 'ended') {
                        console.log('Call ended by other party');
                        endCall();
                    }
                }, error => {
                    console.error('Call snapshot listener error:', error);
                });
                callListeners.push(callSnapshotListener);

                const offerCandidatesListener = offerCandidates.onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(async change => {
                        if (change.type === 'added') {
                            console.log('Received offer candidate:', change.doc.data());
                            const candidate = new RTCIceCandidate(change.doc.data());
                            await peerConnection.addIceCandidate(candidate).catch(error => {
                                console.error('Error adding ICE candidate:', error);
                            });
                        }
                    });
                }, error => {
                    console.error('Offer candidates listener error:', error);
                });
                callListeners.push(offerCandidatesListener);

                peerConnection.onicecandidate = async event => {
                    if (event.candidate) {
                        console.log('Sending answer ICE candidate:', event.candidate);
                        await retryFirestoreOperation(() =>
                            answerCandidates.add(event.candidate.toJSON())
                        );
                    }
                };
            } catch (error) {
                console.error('Error accepting call:', error);
                callStatus.textContent = 'Error accepting call: ' + error.message;
                await resetCallState();
            }
        }

        async function rejectCall() {
            incomingCallAlert.style.display = 'none';
            callStatus.textContent = 'Call rejected';
            setTimeout(() => callStatus.textContent = '', 3000);

            try {
                const user = auth.currentUser;
                const callDocId = incomingCallAlert.dataset.callDocId;
                console.log('Rejecting call with doc ID:', callDocId);

                const callDocRef = db.collection('users').doc(user.uid).collection('calls').doc(callDocId);
                await retryFirestoreOperation(() => callDocRef.delete());
                console.log('Call notification deleted');

                if (callerCallId && callDoc) {
                    const callerCallIdDoc = await retryFirestoreOperation(() =>
                        db.collection('callIds').doc(callerCallId).get()
                    );
                    if (callerCallIdDoc.exists) {
                        const callerUid = callerCallIdDoc.data().uid;
                        await retryFirestoreOperation(() =>
                            db.collection('users').doc(callerUid).collection('calls').doc(callDoc.id).delete()
                        );
                        console.log('Caller’s call notification deleted');
                    }
                }
            } catch (error) {
                console.error('Error rejecting call:', error);
                callStatus.textContent = 'Error rejecting call: ' + error.message;
            }

            await resetCallState();
        }

        async function endCall() {
            console.log('Ending call');
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }

            try {
                const user = auth.currentUser;
                if (isCaller && targetCallId && callDoc) {
                    const targetCallIdDoc = await retryFirestoreOperation(() =>
                        db.collection('callIds').doc(targetCallId).get()
                    );
                    if (targetCallIdDoc.exists) {
                        const targetUid = targetCallIdDoc.data().uid;
                        await retryFirestoreOperation(() =>
                            db.collection('users').doc(targetUid).collection('calls').doc(callDoc.id).delete()
                        );
                        console.log('Target user’s call notification deleted');
                    }
                    await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).collection('calls').doc(callDoc.id).delete()
                    );
                    console.log('Caller’s call notification deleted');
                    await retryFirestoreOperation(() =>
                        callDoc.update({ status: 'ended', endedAt: firebase.firestore.FieldValue.serverTimestamp() })
                    );
                } else if (callerCallId && callDoc) {
                    const callerCallIdDoc = await retryFirestoreOperation(() =>
                        db.collection('callIds').doc(callerCallId).get()
                    );
                    if (callerCallIdDoc.exists) {
                        const callerUid = callerCallIdDoc.data().uid;
                        await retryFirestoreOperation(() =>
                            db.collection('users').doc(callerUid).collection('calls').doc(callDoc.id).delete()
                        );
                        console.log('Caller’s call notification deleted');
                    }
                    await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).collection('calls').doc(callDoc.id).delete()
                    );
                    console.log('Callee’s call notification deleted');
                    await retryFirestoreOperation(() =>
                        callDoc.update({ status: 'ended', endedAt: firebase.firestore.FieldValue.serverTimestamp() })
                    );
                }
            } catch (error) {
                console.error('Error ending call:', error);
                callStatus.textContent = 'Error ending call: ' + error.message;
            }

            await resetCallState();
            callStatus.textContent = 'Call ended';
            setTimeout(() => callStatus.textContent = '', 3000);
        }

        async function createPeerConnection() {
            if (!localStream || !localStream.active) {
                console.log('Local stream not available or inactive, initializing...');
                const mediaSuccess = await initMediaStream();
                if (!mediaSuccess || !localStream) {
                    callStatus.textContent = 'Cannot start call: Camera/microphone not available';
                    throw new Error('Failed to initialize media stream');
                }
            }

            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(configuration);
            remoteStream = new MediaStream();
            remoteVideo.srcObject = remoteStream;
            remotePlaceholder.style.display = 'none';
            remoteVideo.style.display = 'block';

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
                console.log('Added track to peerConnection:', track);
            });

            peerConnection.ontrack = event => {
                console.log('ontrack event:', event);
                if (event.streams[0]) {
                    event.streams[0].getTracks().forEach(track => {
                        remoteStream.addTrack(track);
                        console.log('Added remote track:', track);
                    });
                    remoteVideo.srcObject = remoteStream;
                    remotePlaceholder.style.display = 'none';
                    remoteVideo.style.display = 'block';
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'disconnected' || 
                    peerConnection.connectionState === 'failed') {
                    console.log('Connection failed or disconnected, ending call');
                    endCall();
                } else if (peerConnection.connectionState === 'connected') {
                    console.log('Peer connection established successfully');
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'failed') {
                    console.log('Restarting ICE');
                    peerConnection.restartIce();
                }
            };
        }

        function toggleCamera() {
            if (!localStream) {
                console.log('Cannot toggle camera: Local stream not available');
                callStatus.textContent = 'Camera not available';
                return;
            }
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('toggleCam').textContent = 
                    videoTrack.enabled ? 'Camera Off' : 'Camera On';
                console.log('Camera toggled:', videoTrack.enabled ? 'On' : 'Off');
            }
        }

        function toggleMic() {
            if (!localStream) {
                console.log('Cannot toggle mic: Local stream not available');
                callStatus.textContent = 'Microphone not available';
                return;
            }
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('toggleMic').textContent = 
                    audioTrack.enabled ? 'Mic Off' : 'Mic On';
                console.log('Microphone toggled:', audioTrack.enabled ? 'On' : 'Off');
            }
        }

        auth.onAuthStateChanged(async user => {
            console.log('Auth state changed:', user ? `User logged in: ${user.uid}` : 'No user');
            if (user) {
                console.log('Checking user data in Firestore...');
                try {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const userDoc = await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).get()
                    );
                    console.log('Firestore query completed, exists:', userDoc.exists, 'data:', userDoc.data());

                    if (userDoc.exists && userDoc.data().callId) {
                        console.log(`CallId found: ${userDoc.data().callId}, initializing call section`);
                        myCallId = userDoc.data().callId;
                        await initCallSection();
                        showSection(callContainer);
                        authStatus.textContent = '';
                    } else {
                        console.log('No callId found, showing call ID creation');
                        showSection(callIdContainer);
                        authStatus.textContent = '';
                    }
                } catch (error) {
                    console.error('Error checking user data:', error);
                    authStatus.textContent = 'Error loading user data: ' + error.message;
                }
            } else {
                console.log('No user, showing auth section');
                await resetCallState();
                showSection(authContainer);
                authStatus.textContent = '';
            }
        });

        window.onbeforeunload = async () => {
            try {
                const user = auth.currentUser;
                if (user) {
                    await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).update({
                            online: false,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                        })
                    );
                }
                await resetCallState();
            } catch (error) {
                console.error('Error during cleanup:', error);
            }
        };
    </script>
</body>
</html>
