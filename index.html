<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VideoCall Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Poppins', sans-serif; }
        body { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; color: white; display: flex; align-items: center; justify-content: center; padding: 20px; }
        .auth-container, .callid-container, .call-container { background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 40px; width: 100%; max-width: 1200px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2); backdrop-filter: blur(10px); text-align: center; display: none; }
        .active { display: block; }
        h2 { margin-bottom: 20px; }
        .form-group { margin-bottom: 20px; }
        input { width: 100%; padding: 12px; border-radius: 25px; border: none; background: rgba(255, 255, 255, 0.2); color: white; font-size: 16px; }
        input::placeholder { color: rgba(255, 255, 255, 0.7); }
        button { padding: 12px 25px; border: none; border-radius: 25px; background: rgba(255, 255, 255, 0.2); color: white; cursor: pointer; transition: all 0.3s ease; font-size: 16px; }
        button:hover { background: rgba(255, 255, 255, 0.3); transform: translateY(-2px); }
        button:active { transform: scale(0.95); }
        .toggle-link { color: #a1c4fd; cursor: pointer; text-decoration: underline; margin-top: 10px; display: inline-block; }
        .status { margin-top: 20px; min-height: 24px; color: #ff4d4d; }
        .video-container { display: flex; gap: 20px; margin-top: 40px; }
        .video-box { flex: 1; background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 15px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1); backdrop-filter: blur(10px); min-height: 400px; display: flex; align-items: center; justify-content: center; }
        video { width: 100%; border-radius: 10px; transform: scaleX(-1); max-height: 400px; object-fit: cover; }
        .placeholder { text-align: center; color: rgba(255, 255, 255, 0.7); }
        .controls { display: flex; justify-content: center; gap: 15px; margin-top: 20px; flex-wrap: wrap; }
        .code-section { text-align: center; margin-top: 40px; }
        .call-alert { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 0, 0, 0.9); padding: 30px; border-radius: 15px; text-align: center; animation: popIn 0.3s ease; z-index: 100; }
        @keyframes popIn { from { transform: translate(-50%, -50%) scale(0.5); } to { transform: translate(-50%, -50%) scale(1); } }
        @media (max-width: 768px) {
            .auth-container, .callid-container, .call-container { padding: 20px; }
            .video-container { flex-direction: column; gap: 10px; }
            .video-box { min-height: 200px; max-height: 300px; width: 100%; }
            video { max-height: 250px; }
            .local-video-box { order: 1; }
            .remote-video-box { order: 2; }
            .controls { gap: 10px; padding: 10px; justify-content: center; }
            button { padding: 10px 20px; font-size: 14px; }
            input { width: 80%; max-width: 250px; }
        }
    </style>
</head>
<body>
    <div class="auth-container" id="authContainer">
        <h2 id="formTitle">Login</h2>
        <div class="form-group"><input type="email" id="email" placeholder="Email" required></div>
        <div class="form-group"><input type="password" id="password" placeholder="Password" required></div>
        <button id="authButton" onclick="handleAuth()">Login</button>
        <div class="toggle-link" onclick="toggleForm()">Don't have an account? Sign Up</div>
        <div class="status" id="authStatus"></div>
    </div>

    <div class="callid-container" id="callIdContainer">
        <h2>Create Your Call ID</h2>
        <div class="form-group"><input type="text" id="callIdInput" placeholder="Enter unique Call ID (e.g., raghu123)" required></div>
        <button onclick="saveCallId()">Save Call ID</button>
        <div class="status" id="callIdStatus"></div>
    </div>

    <div class="call-container" id="callContainer">
        <div class="code-section">
            <h2>Your Call ID: <span id="myCallId"></span></h2>
            <button onclick="signOut()">Sign Out</button>
            <input type="text" id="targetCallId" placeholder="Enter Call ID to call">
            <button onclick="startCall()">Call</button>
            <div class="status" id="callStatus"></div>
        </div>
        <div class="video-container">
            <div class="video-box local-video-box">
                <video id="localVideo" autoplay muted></video>
                <div id="localPlaceholder" class="placeholder">Your camera will appear here</div>
            </div>
            <div class="video-box remote-video-box">
                <video id="remoteVideo" autoplay></video>
                <div id="remotePlaceholder" class="placeholder">Waiting for connection...</div>
            </div>
        </div>
        <div class="controls">
            <button id="toggleCam" onclick="toggleCamera()">Camera Off</button>
            <button id="toggleMic" onclick="toggleMic()">Mic Off</button>
            <button id="endCall" onclick="endCall()" style="display: none; background: #ff4d4d;">End Call</button>
        </div>
        <div id="incomingCallAlert" class="call-alert" style="display: none;">
            <h2>Incoming Call from <span id="callerId"></span></h2>
            <button onclick="acceptCall()">Accept</button>
            <button onclick="rejectCall()" style="background: #ff4d4d;">Reject</button>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyAyBQ5XefqnuXOj6tdYlFiied5sVFoOE40",
            authDomain: "live-call-33ea7.firebaseapp.com",
            projectId: "live-call-33ea7",
            storageBucket: "live-call-33ea7.firebasestorage.app",
            messagingSenderId: "518167322129",
            appId: "1:518167322129:web:caf131eb4c4bec2272dbb0"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        
        const authContainer = document.getElementById('authContainer');
        const callIdContainer = document.getElementById('callIdContainer');
        const callContainer = document.getElementById('callContainer');
        const formTitle = document.getElementById('formTitle');
        const authButton = document.getElementById('authButton');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');
        const authStatus = document.getElementById('authStatus');
        const callIdInput = document.getElementById('callIdInput');
        const callIdStatus = document.getElementById('callIdStatus');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const localPlaceholder = document.getElementById('localPlaceholder');
        const remotePlaceholder = document.getElementById('remotePlaceholder');
        const callStatus = document.getElementById('callStatus');
        const incomingCallAlert = document.getElementById('incomingCallAlert');
        const callerIdSpan = document.getElementById('callerId');
        const endCallBtn = document.getElementById('endCall');
        const myCallIdSpan = document.getElementById('myCallId');

        let isLogin = true;
        let localStream;
        let remoteStream;
        let peerConnection;
        let myCallId;
        let targetCallId;
        let callerCallId;
        let isCaller = false;
        let callDoc;
        let callListeners = [];

        function showSection(section) {
            authContainer.classList.remove('active');
            callIdContainer.classList.remove('active');
            callContainer.classList.remove('active');
            section.classList.add('active');
        }

        function toggleForm() {
            isLogin = !isLogin;
            formTitle.textContent = isLogin ? 'Login' : 'Sign Up';
            authButton.textContent = isLogin ? 'Login' : 'Sign Up';
            authStatus.textContent = '';
            document.querySelector('.toggle-link').textContent = isLogin ? "Don't have an account? Sign Up" : 'Already have an account? Login';
        }

        async function handleAuth() {
            const email = emailInput.value.trim();
            const password = passwordInput.value.trim();
            authStatus.textContent = '';

            if (!email || !password) {
                authStatus.textContent = 'Please enter email and password';
                return;
            }

            try {
                if (isLogin) {
                    await auth.signInWithEmailAndPassword(email, password);
                    authStatus.textContent = 'Login successful, loading...';
                } else {
                    await auth.createUserWithEmailAndPassword(email, password);
                    showSection(callIdContainer);
                }
            } catch (error) {
                authStatus.textContent = error.message;
            }
        }

        async function saveCallId() {
            const callId = callIdInput.value.trim();
            callIdStatus.textContent = '';

            if (!callId || callId.length < 4) {
                callIdStatus.textContent = 'Call ID must be at least 4 characters';
                return;
            }

            try {
                const callIdDoc = await db.collection('callIds').doc(callId).get();
                if (callIdDoc.exists) {
                    callIdStatus.textContent = 'Call ID already taken';
                    return;
                }

                const user = auth.currentUser;
                await db.collection('users').doc(user.uid).set({
                    callId: callId,
                    online: true,
                    lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });

                await db.collection('callIds').doc(callId).set({ uid: user.uid });
                myCallId = callId;
                await initCallSection();
                showSection(callContainer);
            } catch (error) {
                callIdStatus.textContent = error.message;
            }
        }

        function signOut() {
            auth.signOut().then(() => {
                resetCallState();
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                showSection(authContainer);
            }).catch(error => {
                callStatus.textContent = 'Error signing out';
            });
        }

        function stopLocalStream() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            localVideo.srcObject = null;
            localPlaceholder.style.display = 'block';
            localVideo.style.display = 'none';
        }

        function stopRemoteStream() {
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }
            remoteVideo.srcObject = null;
            remotePlaceholder.style.display = 'block';
            remoteVideo.style.display = 'none';
        }

        function resetCallState() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            stopRemoteStream();
            endCallBtn.style.display = 'none';
            incomingCallAlert.style.display = 'none';
            targetCallId = null;
            callerCallId = null;
            isCaller = false;
            callDoc = null;
            callListeners.forEach(unsubscribe => unsubscribe());
            callListeners = [];
            callStatus.textContent = '';
        }

        async function initMediaStream() {
            try {
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: 'user' },
                    audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
                });
                localVideo.srcObject = localStream;
                localPlaceholder.style.display = 'none';
                localVideo.style.display = 'block';
                return true;
            } catch (error) {
                callStatus.textContent = 'Could not access camera/microphone. Please grant permissions.';
                return false;
            }
        }

        async function createPeerConnection() {
            try {
                if (!localStream || localStream.getTracks().length === 0) {
                    const mediaSuccess = await initMediaStream();
                    if (!mediaSuccess) throw new Error('Could not initialize media stream');
                }

                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                };

                peerConnection = new RTCPeerConnection(configuration);
                remoteStream = new MediaStream();
                remoteVideo.srcObject = remoteStream;
                remotePlaceholder.style.display = 'none';
                remoteVideo.style.display = 'block';

                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                peerConnection.ontrack = event => {
                    if (event.streams && event.streams[0]) {
                        event.streams[0].getTracks().forEach(track => {
                            remoteStream.addTrack(track);
                        });
                    } else {
                        remoteStream.addTrack(event.track);
                    }
                    remoteVideo.srcObject = remoteStream;
                };

                peerConnection.onconnectionstatechange = () => {
                    if (peerConnection.connectionState === 'connected') {
                        callStatus.textContent = `Connected with ${isCaller ? targetCallId : callerCallId}`;
                        endCallBtn.style.display = 'block';
                    } else if (peerConnection.connectionState === 'disconnected' || 
                              peerConnection.connectionState === 'failed') {
                        endCall();
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    if (peerConnection.iceConnectionState === 'failed') {
                        peerConnection.restartIce();
                    }
                };

                return true;
            } catch (error) {
                callStatus.textContent = 'Error setting up connection: ' + error.message;
                throw error;
            }
        }

        async function startCall() {
            try {
                const mediaSuccess = await initMediaStream();
                if (!mediaSuccess) return;

                resetCallState();
                targetCallId = document.getElementById('targetCallId').value.trim();
                if (!targetCallId) {
                    callStatus.textContent = 'Please enter a Call ID to call';
                    return;
                }
                if (targetCallId === myCallId) {
                    callStatus.textContent = "You can't call yourself";
                    return;
                }

                callStatus.textContent = `Calling ${targetCallId}...`;
                isCaller = true;

                const targetCallIdDoc = await db.collection('callIds').doc(targetCallId).get();
                if (!targetCallIdDoc.exists) {
                    callStatus.textContent = 'Call ID not found';
                    return;
                }

                const targetUid = targetCallIdDoc.data().uid;
                await createPeerConnection();

                callDoc = db.collection('calls').doc();
                const offerCandidates = callDoc.collection('offerCandidates');
                const answerCandidates = callDoc.collection('answerCandidates');

                const callData = {
                    caller: myCallId,
                    callId: callDoc.id,
                    status: 'calling',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                };

                const batch = db.batch();
                batch.set(db.collection('users').doc(targetUid).collection('calls').doc(callDoc.id), callData);
                await batch.commit();

                const offerDescription = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offerDescription);

                const offer = {
                    sdp: offerDescription.sdp,
                    type: offerDescription.type,
                    caller: myCallId,
                    callee: targetCallId
                };

                await callDoc.set({ offer });

                const callSnapshotListener = callDoc.onSnapshot(async snapshot => {
                    const data = snapshot.data();
                    if (!peerConnection.currentRemoteDescription && data?.answer) {
                        const answerDescription = new RTCSessionDescription(data.answer);
                        await peerConnection.setRemoteDescription(answerDescription);
                    }
                    if (data?.status === 'ended') {
                        endCall();
                    }
                });
                callListeners.push(callSnapshotListener);

                const answerCandidatesListener = answerCandidates.onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(async change => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            await peerConnection.addIceCandidate(candidate).catch(console.error);
                        }
                    });
                });
                callListeners.push(answerCandidatesListener);

                peerConnection.onicecandidate = async event => {
                    if (event.candidate) {
                        await offerCandidates.add(event.candidate.toJSON());
                    }
                };

                setTimeout(() => {
                    if (!peerConnection.currentRemoteDescription) {
                        callStatus.textContent = 'Call timed out';
                        endCall();
                    }
                }, 30000);
            } catch (error) {
                callStatus.textContent = 'Error starting call: ' + error.message;
                endCall();
            }
        }

        async function acceptCall() {
            try {
                const mediaSuccess = await initMediaStream();
                if (!mediaSuccess) {
                    incomingCallAlert.style.display = 'none';
                    return;
                }

                resetCallState();
                incomingCallAlert.style.display = 'none';
                callStatus.textContent = `Connecting with ${callerCallId}...`;

                await createPeerConnection();

                const user = auth.currentUser;
                const callDocId = incomingCallAlert.dataset.callDocId;
                const callDocRef = db.collection('users').doc(user.uid).collection('calls').doc(callDocId);
                const callDocSnap = await callDocRef.get();

                if (!callDocSnap.exists) {
                    callStatus.textContent = 'Call no longer exists';
                    return;
                }

                const callData = callDocSnap.data();
                callDoc = db.collection('calls').doc(callData.callId);
                const offerCandidates = callDoc.collection('offerCandidates');
                const answerCandidates = callDoc.collection('answerCandidates');

                await callDocRef.update({
                    status: 'answered',
                    answeredAt: firebase.firestore.FieldValue.serverTimestamp()
                });

                const callSnapshotListener = callDoc.onSnapshot(async snapshot => {
                    const data = snapshot.data();
                    if (!peerConnection.currentRemoteDescription && data?.offer) {
                        const offerDescription = new RTCSessionDescription(data.offer);
                        await peerConnection.setRemoteDescription(offerDescription);

                        const answerDescription = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answerDescription);

                        const answer = {
                            type: answerDescription.type,
                            sdp: answerDescription.sdp
                        };

                        await callDoc.update({ answer });
                        await callDocRef.delete();
                    }
                    if (data?.status === 'ended') {
                        endCall();
                    }
                });
                callListeners.push(callSnapshotListener);

                const offerCandidatesListener = offerCandidates.onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(async change => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            await peerConnection.addIceCandidate(candidate).catch(console.error);
                        }
                    });
                });
                callListeners.push(offerCandidatesListener);

                peerConnection.onicecandidate = async event => {
                    if (event.candidate) {
                        await answerCandidates.add(event.candidate.toJSON());
                    }
                };
            } catch (error) {
                callStatus.textContent = 'Error accepting call: ' + error.message;
                endCall();
            }
        }

        async function rejectCall() {
            incomingCallAlert.style.display = 'none';
            callStatus.textContent = 'Call rejected';
            setTimeout(() => callStatus.textContent = '', 3000);

            try {
                const user = auth.currentUser;
                const callDocId = incomingCallAlert.dataset.callDocId;
                const callDocRef = db.collection('users').doc(user.uid).collection('calls').doc(callDocId);
                await callDocRef.delete();

                if (callerCallId && callDoc) {
                    const callerCallIdDoc = await db.collection('callIds').doc(callerCallId).get();
                    if (callerCallIdDoc.exists) {
                        const callerUid = callerCallIdDoc.data().uid;
                        await db.collection('users').doc(callerUid).collection('calls').doc(callDoc.id).delete();
                    }
                }
            } catch (error) {
                callStatus.textContent = 'Error rejecting call: ' + error.message;
            }
            endCall();
        }

        async function endCall() {
            if (peerConnection) peerConnection.close();
            stopRemoteStream();
            endCallBtn.style.display = 'none';

            try {
                const user = auth.currentUser;
                if (isCaller && targetCallId && callDoc) {
                    const targetCallIdDoc = await db.collection('callIds').doc(targetCallId).get();
                    if (targetCallIdDoc.exists) {
                        const targetUid = targetCallIdDoc.data().uid;
                        await db.collection('users').doc(targetUid).collection('calls').doc(callDoc.id).delete();
                    }
                    await db.collection('users').doc(user.uid).collection('calls').doc(callDoc.id).delete();
                    await callDoc.update({ status: 'ended', endedAt: firebase.firestore.FieldValue.serverTimestamp() });
                } else if (callerCallId && callDoc) {
                    const callerCallIdDoc = await db.collection('callIds').doc(callerCallId).get();
                    if (callerCallIdDoc.exists) {
                        const callerUid = callerCallIdDoc.data().uid;
                        await db.collection('users').doc(callerUid).collection('calls').doc(callDoc.id).delete();
                    }
                    await db.collection('users').doc(user.uid).collection('calls').doc(callDoc.id).delete();
                    await callDoc.update({ status: 'ended', endedAt: firebase.firestore.FieldValue.serverTimestamp() });
                }
            } catch (error) {
                console.error('Error ending call:', error);
            }

            resetCallState();
            callStatus.textContent = 'Call ended';
            setTimeout(() => callStatus.textContent = '', 3000);
            initMediaStream();
        }

        function toggleCamera() {
            if (!localStream) return;
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('toggleCam').textContent = videoTrack.enabled ? 'Camera Off' : 'Camera On';
            }
        }

        function toggleMic() {
            if (!localStream) return;
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('toggleMic').textContent = audioTrack.enabled ? 'Mic Off' : 'Mic On';
            }
        }

        async function initCallSection() {
            try {
                myCallIdSpan.textContent = myCallId;
                await db.collection('users').doc(auth.currentUser.uid).set({
                    online: true,
                    lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });

                await cleanupOldCalls();

                const callListener = db.collection('users').doc(auth.currentUser.uid).collection('calls').onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added' || change.type === 'modified') {
                            const callData = change.doc.data();
                            handleIncomingCall(callData, change.doc.id);
                        }
                    });
                });
                callListeners.push(callListener);

                await initMediaStream();
            } catch (error) {
                callStatus.textContent = 'Error loading call data. Please sign out and try again.';
            }
        }

        async function cleanupOldCalls() {
            try {
                const user = auth.currentUser;
                const calls = await db.collection('users').doc(user.uid).collection('calls').get();
                for (const doc of calls.docs) {
                    await doc.ref.delete();
                }
            } catch (error) {
                console.error('Error cleaning up old calls:', error);
            }
        }

        function handleIncomingCall(callData, callDocId) {
            if (callData.status === 'calling') {
                const now = new Date();
                const callTime = callData.timestamp?.toDate();
                if (callTime && (now - callTime > 60000)) {
                    db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete();
                    return;
                }
                callerCallId = callData.caller;
                callerIdSpan.textContent = callerCallId;
                incomingCallAlert.style.display = 'block';
                callStatus.textContent = `Incoming call from ${callerCallId}`;
                incomingCallAlert.dataset.callDocId = callDocId;
            } else {
                incomingCallAlert.style.display = 'none';
                if (callData.status === 'ended' && (peerConnection || localStream)) {
                    endCall();
                } else {
                    callStatus.textContent = callData.status === 'rejected' ? 'Call was rejected' : 
                                          callData.status === 'answered' ? 'Call connected' : '';
                    if (callStatus.textContent) {
                        setTimeout(() => callStatus.textContent = '', 3000);
                    }
                }
                db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete();
            }
        }

        auth.onAuthStateChanged(async user => {
            if (user) {
                try {
                    const userDoc = await db.collection('users').doc(user.uid).get();
                    if (userDoc.exists && userDoc.data().callId) {
                        myCallId = userDoc.data().callId;
                        await initCallSection();
                        showSection(callContainer);
                    } else {
                        showSection(callIdContainer);
                    }
                } catch (error) {
                    authStatus.textContent = 'Error loading user data: ' + error.message;
                }
            } else {
                resetCallState();
                showSection(authContainer);
            }
        });

        window.onbeforeunload = async () => {
            try {
                const user = auth.currentUser;
                if (user) {
                    await db.collection('users').doc(user.uid).update({
                        online: false,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    });
                }
                resetCallState();
            } catch (error) {
                console.error('Error during cleanup:', error);
            }
        };
    </script>
</body>
</html>
