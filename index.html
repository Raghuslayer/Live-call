<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VideoCall Pro</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1e1b4b 0%, #3b2a6b 100%);
            min-height: 100vh;
            color: #e0e7ff;
            display: grid;
            place-items: center;
            padding: 1rem;
            overflow-x: hidden;
        }

        .auth-container, .callid-container, .call-container {
            background: rgba(30, 27, 75, 0.85);
            border-radius: 12px;
            padding: 1.5rem;
            width: 100%;
            max-width: 900px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            text-align: center;
            display: none;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        .auth-container:not(.active), .callid-container:not(.active), .call-container:not(.active) {
            opacity: 0;
            transform: translateY(20px);
        }

        h2 {
            margin-bottom: 1rem;
            font-weight: 600;
            color: #a5b4fc;
            font-size: 1.75rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        input {
            width: 100%;
            padding: 0.75rem 0;
            border: none;
            border-bottom: 2px solid rgba(165, 180, 252, 0.3);
            background: transparent;
            color: #e0e7ff;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        input:focus {
            outline: none;
            border-color: #a5b4fc;
        }

        input::placeholder {
            color: rgba(165, 180, 252, 0.5);
        }

        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 50px;
            background: linear-gradient(45deg, #a5b4fc, #f472b6);
            color: #fff;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        button:hover {
            box-shadow: 0 4px 15px rgba(164, 165, 252, 0.5);
            transform: translateY(-2px);
        }

        button:active {
            transform: scale(0.98);
        }

        .toggle-link {
            color: #a5b4fc;
            cursor: pointer;
            text-decoration: none;
            margin-top: 0.75rem;
            display: inline-block;
            font-size: 0.9rem;
            transition: color 0.3s ease;
        }

        .toggle-link:hover {
            color: #f472b6;
        }

        .status {
            margin-top: 0.75rem;
            min-height: 1.5rem;
            color: #f472b6;
            font-size: 0.875rem;
        }

        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .video-box {
            background: rgba(30, 27, 75, 0.7);
            border-radius: 10px;
            padding: 0.75rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(8px);
            min-height: 200px;
            display: grid;
            place-items: center;
            position: relative;
            overflow: hidden;
        }

        video {
            width: 100%;
            border-radius: 8px;
            transform: scaleX(-1);
            max-height: 300px;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        video.active {
            opacity: 1;
        }

        .placeholder {
            color: rgba(165, 180, 252, 0.5);
            font-size: 0.9rem;
        }

        .loading-animation {
            display: none;
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #a5b4fc 0%, transparent 70%);
            animation: pulse 1.5s infinite ease-in-out;
        }

        .loading-animation.active {
            display: block;
        }

        @keyframes pulse {
            0% { transform: scale(0.8); opacity: 0.7; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(0.8); opacity: 0.7; }
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .code-section {
            margin-top: 1.5rem;
        }

        .call-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 27, 75, 0.9);
            padding: 1.5rem;
            border-radius: 12px;
            text-align: center;
            animation: popIn 0.4s ease;
            z-index: 100;
            box-shadow: 0 0 20px rgba(165, 180, 252, 0.5);
        }

        .call-alert button {
            margin: 0.5rem;
        }

        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0.7); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        @media (max-width: 768px) {
            .auth-container, .callid-container, .call-container {
                padding: 1rem;
                max-width: 100%;
            }

            h2 {
                font-size: 1.5rem;
            }

            input {
                font-size: 0.9rem;
            }

            button {
                padding: 0.6rem 1.2rem;
                font-size: 0.9rem;
            }

            .video-box {
                min-height: 150px;
                max-height: 200px;
            }

            video {
                max-height: 180px;
            }
        }

        @media (min-width: 769px) {
            .video-container {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="auth-container active" id="authContainer">
        <h2 id="formTitle">Login</h2>
        <div class="form-group">
            <input type="email" id="email" placeholder="Email" required>
        </div>
        <div class="form-group">
            <input type="password" id="password" placeholder="Password" required>
        </div>
        <button id="authButton" onclick="handleAuth()">Login</button>
        <div class="toggle-link" onclick="toggleForm()">Don't have an account? Sign Up</div>
        <div class="status" id="authStatus"></div>
    </div>

    <div class="callid-container" id="callIdContainer">
        <h2>Create Your Call ID</h2>
        <div class="form-group">
            <input type="text" id="callIdInput" placeholder="Enter unique Call ID (e.g., raghu123)" required>
        </div>
        <button onclick="saveCallId()">Save Call ID</button>
        <div class="status" id="callIdStatus"></div>
    </div>

    <div class="call-container" id="callContainer">
        <div class="code-section">
            <h2>Your Call ID: <span id="myCallId"></span></h2>
            <div class="controls">
                <button onclick="signOut()">Sign Out</button>
                <input type="text" id="targetCallId" placeholder="Enter Call ID to call">
                <button onclick="startCall()">Call</button>
            </div>
            <div class="status" id="callStatus"></div>
        </div>

        <div class="video-container">
            <div class="video-box local-video-box">
                <video id="localVideo" autoplay muted playsinline></video>
                <div id="localPlaceholder" class="placeholder">Your camera will appear here</div>
            </div>
            <div class="video-box remote-video-box">
                <video id="remoteVideo" autoplay playsinline></video>
                <div id="remotePlaceholder" class="placeholder">Waiting for connection...</div>
                <div class="loading-animation" id="remoteLoading"></div>
            </div>
        </div>

        <div class="controls">
            <button id="toggleCam" onclick="toggleCamera()">Camera Off</button>
            <button id="toggleMic" onclick="toggleMic()">Mic Off</button>
            <button id="endCall" onclick="endCall()" style="display: none; background: linear-gradient(45deg, #f472b6, #ff4d4d);">End Call</button>
        </div>

        <div id="incomingCallAlert" class="call-alert" style="display: none;">
            <h2>Incoming Call from <span id="callerId"></span></h2>
            <button onclick="acceptCall()">Accept</button>
            <button onclick="rejectCall()" style="background: linear-gradient(45deg, #f472b6, #ff4d4d);">Reject</button>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyAyBQ5XefqnuXOj6tdYlFiied5sVFoOE40",
            authDomain: "live-call-33ea7.firebaseapp.com",
            projectId: "live-call-33ea7",
            storageBucket: "live-call-33ea7.firebasestorage.app",
            messagingSenderId: "518167322129",
            appId: "1:518167322129:web:caf131eb4c4bec2272dbb0"
        };

        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        firebase.firestore.setLogLevel('debug');

        const authContainer = document.getElementById('authContainer');
        const callIdContainer = document.getElementById('callIdContainer');
        const callContainer = document.getElementById('callContainer');
        const formTitle = document.getElementById('formTitle');
        const authButton = document.getElementById('authButton');
        const emailInput = document.getElementById('email');
        const passwordInput = document.getElementById('password');
        const authStatus = document.getElementById('authStatus');
        const callIdInput = document.getElementById('callIdInput');
        const callIdStatus = document.getElementById('callIdStatus');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const localPlaceholder = document.getElementById('localPlaceholder');
        const remotePlaceholder = document.getElementById('remotePlaceholder');
        const remoteLoading = document.getElementById('remoteLoading');
        const callStatus = document.getElementById('callStatus');
        const incomingCallAlert = document.getElementById('incomingCallAlert');
        const callerIdSpan = document.getElementById('callerId');
        const endCallBtn = document.getElementById('endCall');
        const myCallIdSpan = document.getElementById('myCallId');

        let isLogin = true;
        let localStream;
        let remoteStream;
        let peerConnection;
        let myCallId;
        let targetCallId;
        let callerCallId;
        let isCaller = false;
        let callDoc;
        let callListeners = [];
        let isMediaStreamInitialized = false;
        let isCallActive = false;
        let pendingIceCandidates = [];

        function showSection(section) {
            console.log(`Showing section: ${section.id}`);
            authContainer.classList.remove('active');
            callIdContainer.classList.remove('active');
            callContainer.classList.remove('active');
            section.classList.add('active');
            section.offsetHeight;
        }

        function toggleForm() {
            isLogin = !isLogin;
            formTitle.textContent = isLogin ? 'Login' : 'Sign Up';
            authButton.textContent = isLogin ? 'Login' : 'Sign Up';
            authStatus.textContent = '';
            document.querySelector('.toggle-link').textContent = isLogin ? "Don't have an account? Sign Up" : 'Already have an account? Login';
        }

        async function handleAuth() {
            const email = emailInput.value.trim();
            const password = passwordInput.value.trim();
            authStatus.textContent = '';

            if (!email || !password) {
                authStatus.textContent = 'Please enter email and password';
                return;
            }

            try {
                if (isLogin) {
                    console.log('Attempting login with:', email);
                    await auth.signInWithEmailAndPassword(email, password);
                    console.log('Login successful');
                    authStatus.textContent = 'Login successful, loading...';
                } else {
                    console.log('Attempting signup with:', email);
                    await auth.createUserWithEmailAndPassword(email, password);
                    console.log('Signup successful, showing call ID creation');
                    showSection(callIdContainer);
                    authStatus.textContent = '';
                }
            } catch (error) {
                console.error('Auth error:', error.message);
                authStatus.textContent = error.message;
            }
        }

        async function saveCallId() {
            const callId = callIdInput.value.trim();
            callIdStatus.textContent = '';

            if (!callId || callId.length < 4) {
                callIdStatus.textContent = 'Call ID must be at least 4 characters';
                return;
            }

            try {
                const callIdDoc = await retryFirestoreOperation(() =>
                    db.collection('callIds').doc(callId).get()
                );
                if (callIdDoc.exists) {
                    callIdStatus.textContent = 'Call ID already taken, please choose another';
                    return;
                }

                const user = auth.currentUser;
                await retryFirestoreOperation(() =>
                    db.runTransaction(async transaction => {
                        transaction.set(db.collection('users').doc(user.uid), {
                            callId: callId,
                            online: true,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                        }, { merge: true });
                        transaction.set(db.collection('callIds').doc(callId), { uid: user.uid });
                    })
                );
                console.log(`CallId ${callId} saved, initializing call section`);
                myCallId = callId;
                await initCallSection();
                showSection(callContainer);
            } catch (error) {
                console.error('Error saving callId:', error);
                callIdStatus.textContent = error.message;
            }
        }

        async function signOut() {
            try {
                await auth.signOut();
                console.log('Signed out, showing auth section');
                await resetCallState();
                showSection(authContainer);
                authStatus.textContent = 'Signed out successfully';
            } catch (error) {
                console.error('Sign out error:', error);
                callStatus.textContent = 'Error signing out';
            }
        }

        async function resetCallState() {
            console.log('Resetting call state, isCallActive:', isCallActive);
            isCallActive = false;

            if (peerConnection) {
                try {
                    peerConnection.close();
                } catch (e) {
                    console.error('Error closing peerConnection:', e);
                }
                peerConnection = null;
                console.log('PeerConnection closed');
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Stopped remote track:', track.kind);
                });
                remoteStream = null;
                console.log('Remote stream stopped');
            }
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Stopped local track:', track.kind);
                });
                localStream = null;
                isMediaStreamInitialized = false;
                console.log('Local stream stopped');
            }

            remoteVideo.srcObject = null;
            localVideo.srcObject = null;
            remoteVideo.classList.remove('active');
            localVideo.classList.remove('active');
            remotePlaceholder.style.display = 'block';
            remoteLoading.classList.remove('active');
            localPlaceholder.style.display = 'block';
            localVideo.style.display = 'none';
            endCallBtn.style.display = 'none';
            incomingCallAlert.style.display = 'none';
            targetCallId = null;
            callerCallId = null;
            isCaller = false;
            callDoc = null;
            pendingIceCandidates = [];

            console.log('Unsubscribing listeners, count:', callListeners.length);
            while (callListeners.length > 0) {
                const unsubscribe = callListeners.pop();
                try {
                    unsubscribe();
                } catch (error) {
                    console.error('Error unsubscribing listener:', error);
                }
            }
            console.log('All listeners unsubscribed, callListeners count:', callListeners.length);

            try {
                await cleanupOldCalls();
                console.log('Firestore cleanup completed');
                await new Promise(resolve => setTimeout(resolve, 200));
            } catch (error) {
                console.error('Error during state reset:', error);
                callStatus.textContent = 'Error resetting state: ' + error.message;
            }
        }

        async function initMediaStream() {
            console.log('Initializing media stream');
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Stopped existing track:', track.kind);
                });
                localStream = null;
            }

            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user' },
                    audio: true
                });
                localVideo.srcObject = localStream;
                localPlaceholder.style.display = 'none';
                localVideo.style.display = 'block';
                localVideo.classList.add('active');
                isMediaStreamInitialized = true;
                console.log('Media stream initialized with tracks:', localStream.getTracks().map(t => ({
                    kind: t.kind,
                    enabled: t.enabled,
                    readyState: t.readyState
                })));
                return true;
            } catch (error) {
                console.error('Error initializing media stream:', error);
                callStatus.textContent = 'Could not access camera/microphone. Please grant permissions or check device availability.';
                isMediaStreamInitialized = false;
                return false;
            }
        }

        async function initCallSection() {
            try {
                console.log('Initializing call section for callId:', myCallId);
                myCallIdSpan.textContent = myCallId;

                await retryFirestoreOperation(() =>
                    db.collection('users').doc(auth.currentUser.uid).set({
                        online: true,
                        lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                    }, { merge: true })
                );

                await cleanupOldCalls();

                const callListener = db.collection('users').doc(auth.currentUser.uid).collection('calls').onSnapshot(snapshot => {
                    console.log('Call listener triggered, changes:', snapshot.docChanges().length);
                    snapshot.docChanges().forEach(change => {
                        if (change.type === 'added' || change.type === 'modified') {
                            const callData = change.doc.data();
                            console.log('Received call update:', callData, 'Doc ID:', change.doc.id);
                            if (callData.refreshRequired) {
                                console.log('Refresh required, reloading tab');
                                window.location.reload();
                            } else {
                                handleIncomingCall(callData, change.doc.id);
                            }
                        }
                    });
                }, error => {
                    console.error('Call listener error:', error);
                    callStatus.textContent = 'Error listening for calls: ' + error.message;
                });
                callListeners.push(callListener);

                const mediaSuccess = await initMediaStream();
                if (!mediaSuccess) {
                    callStatus.textContent = 'Media initialization failed. Please grant permissions.';
                }
            } catch (error) {
                console.error('Error initializing call section:', error);
                callStatus.textContent = 'Error loading call data. Please sign out and try again.';
            }
        }

        async function cleanupOldCalls() {
            try {
                const user = auth.currentUser;
                const calls = await retryFirestoreOperation(() =>
                    db.collection('users').doc(user.uid).collection('calls').get()
                );
                const callDocs = await retryFirestoreOperation(() =>
                    db.collection('calls').get()
                );

                const deletePromises = [];
                calls.docs.forEach(doc => {
                    deletePromises.push(retryFirestoreOperation(() => doc.ref.delete()));
                    console.log('Deleted user call document:', doc.id);
                });
                callDocs.docs.forEach(doc => {
                    deletePromises.push(retryFirestoreOperation(() => doc.ref.delete()));
                    console.log('Deleted call document:', doc.id);
                    const offerCandidates = doc.ref.collection('offerCandidates');
                    const answerCandidates = doc.ref.collection('answerCandidates');
                    deletePromises.push(
                        retryFirestoreOperation(() => offerCandidates.get()).then(snapshot =>
                            Promise.all(snapshot.docs.map(d => retryFirestoreOperation(() => d.ref.delete())))
                        ),
                        retryFirestoreOperation(() => answerCandidates.get()).then(snapshot =>
                            Promise.all(snapshot.docs.map(d => retryFirestoreOperation(() => d.ref.delete())))
                        )
                    );
                });
                await Promise.all(deletePromises);
                console.log('Firestore cleanup completed');
            } catch (error) {
                console.error('Error cleaning up old calls:', error);
            }
        }

        async function retryFirestoreOperation(operation, maxAttempts = 3, delay = 1000) {
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    return await operation();
                } catch (error) {
                    console.error(`Firestore operation failed (attempt ${attempt}/${maxAttempts}):`, error);
                    if (attempt === maxAttempts) throw error;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        function handleIncomingCall(callData, callDocId) {
            console.log('Handling incoming call:', callData, 'Doc ID:', callDocId);
            if (isCallActive) {
                console.log('Another call is active, rejecting new call');
                retryFirestoreOperation(() =>
                    db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete()
                );
                return;
            }

            if (callData.status === 'calling') {
                const now = new Date();
                const callTime = callData.timestamp?.toDate();
                if (callTime && (now - callTime > 60000)) {
                    console.log('Ignoring stale call:', callDocId);
                    retryFirestoreOperation(() =>
                        db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete()
                    );
                    return;
                }
                callerCallId = callData.caller;
                if (!callerCallId) {
                    console.error('Caller ID is missing in call data:', callData);
                    callStatus.textContent = 'Invalid call: Caller ID missing';
                    retryFirestoreOperation(() =>
                        db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete()
                    );
                    return;
                }
                callerIdSpan.textContent = callerCallId;
                incomingCallAlert.style.display = 'block';
                callStatus.textContent = `Incoming call from ${callerCallId}`;
                incomingCallAlert.dataset.callDocId = callDocId;
            } else {
                incomingCallAlert.style.display = 'none';
                if (callData.status === 'ended' && (peerConnection || localStream)) {
                    console.log('Call ended by other party, resetting state');
                    endCall();
                } else {
                    callStatus.textContent = callData.status === 'rejected' ? 'Call was rejected' : 
                                            callData.status === 'answered' ? `Call connected with ${callerCallId || 'unknown'}` : 
                                            callData.status === 'completed' ? 'Call completed' : '';
                    if (callStatus.textContent) {
                        setTimeout(() => callStatus.textContent = '', 3000);
                    }
                }
                retryFirestoreOperation(() =>
                    db.collection('users').doc(auth.currentUser.uid).collection('calls').doc(callDocId).delete()
                );
            }
        }

        async function startCall() {
            if (isCallActive) {
                callStatus.textContent = 'Another call is active. Please end the current call first.';
                return;
            }
            isCallActive = true;

            console.log('Starting call');
            const mediaSuccess = await initMediaStream();
            if (!mediaSuccess) {
                callStatus.textContent = 'Failed to access camera/microphone';
                isCallActive = false;
                return;
            }

            targetCallId = document.getElementById('targetCallId').value.trim();
            if (!targetCallId) {
                callStatus.textContent = 'Please enter a Call ID to call';
                isCallActive = false;
                return;
            }
            if (targetCallId === myCallId) {
                callStatus.textContent = "You can't call yourself";
                isCallActive = false;
                return;
            }

            callStatus.textContent = `Calling ${targetCallId}...`;
            remoteLoading.classList.add('active');
            isCaller = true;

            try {
                const targetCallIdDoc = await retryFirestoreOperation(() =>
                    db.collection('callIds').doc(targetCallId).get()
                );
                if (!targetCallIdDoc.exists) {
                    callStatus.textContent = 'Call ID not found';
                    remoteLoading.classList.remove('active');
                    isCallActive = false;
                    return;
                }

                const targetUid = targetCallIdDoc.data().uid;
                await createPeerConnection();

                callDoc = db.collection('calls').doc();
                const offerCandidates = callDoc.collection('offerCandidates');
                const answerCandidates = callDoc.collection('answerCandidates');

                const callData = {
                    caller: myCallId,
                    callId: callDoc.id,
                    status: 'calling',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                };
                await retryFirestoreOperation(() =>
                    db.runTransaction(async transaction => {
                        transaction.set(
                            db.collection('users').doc(targetUid).collection('calls').doc(callDoc.id),
                            callData
                        );
                    })
                );
                console.log(`Call notification written to target user: ${targetUid}, callId: ${callDoc.id}`);

                const offerDescription = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offerDescription);

                const offer = {
                    sdp: offerDescription.sdp,
                    type: offerDescription.type,
                    caller: myCallId,
                    callee: targetCallId
                };

                await retryFirestoreOperation(() => callDoc.set({ offer }));
                console.log('Offer written to call document:', offer);

                const callSnapshotListener = callDoc.onSnapshot(async snapshot => {
                    const data = snapshot.data();
                    console.log('Call snapshot update:', data);
                    if (!peerConnection.currentRemoteDescription && data?.answer) {
                        const answerDescription = new RTCSessionDescription(data.answer);
                        await peerConnection.setRemoteDescription(answerDescription);
                        console.log('Remote description set, applying ICE candidates');
                        for (const candidate of pendingIceCandidates) {
                            await peerConnection.addIceCandidate(candidate).catch(error => {
                                console.error('Error applying ICE candidate:', error);
                            });
                        }
                        pendingIceCandidates = [];
                        callStatus.textContent = `Connected with ${targetCallId}`;
                        remoteLoading.classList.remove('active');
                        endCallBtn.style.display = 'block';
                    }
                    if (data?.status === 'ended') {
                        console.log('Call ended by other party');
                        remoteLoading.classList.remove('active');
                        endCall();
                    }
                }, error => {
                    console.error('Call snapshot listener error:', error);
                    callStatus.textContent = 'Error in call connection: ' + error.message;
                    remoteLoading.classList.remove('active');
                });
                callListeners.push(callSnapshotListener);

                const answerCandidatesListener = answerCandidates.onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(async change => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            console.log('Received answer candidate:', candidate);
                            if (peerConnection.currentRemoteDescription) {
                                await peerConnection.addIceCandidate(candidate).catch(error => {
                                    console.error('Error adding ICE candidate:', error);
                                });
                            } else {
                                pendingIceCandidates.push(candidate);
                                console.log('Buffered ICE candidate:', candidate);
                            }
                        }
                    });
                }, error => {
                    console.error('Answer candidates listener error:', error);
                });
                callListeners.push(answerCandidatesListener);

                peerConnection.onicecandidate = async event => {
                    if (event.candidate) {
                        console.log('Sending ICE candidate:', event.candidate);
                        await retryFirestoreOperation(() =>
                            offerCandidates.add(event.candidate.toJSON())
                        );
                    }
                };

                setTimeout(() => {
                    if (!peerConnection.currentRemoteDescription) {
                        callStatus.textContent = 'Call timed out';
                        remoteLoading.classList.remove('active');
                        endCall();
                    }
                }, 30000);
            } catch (error) {
                console.error('Error starting call:', error);
                callStatus.textContent = 'Error starting call: ' + error.message;
                remoteLoading.classList.remove('active');
                await resetCallState();
                isCallActive = false;
            }
        }

        async function acceptCall() {
            if (isCallActive) {
                callStatus.textContent = 'Another call is active. Please end the current call first.';
                incomingCallAlert.style.display = 'none';
                return;
            }
            isCallActive = true;

            console.log('Accepting call');
            const mediaSuccess = await initMediaStream();
            if (!mediaSuccess) {
                incomingCallAlert.style.display = 'none';
                callStatus.textContent = 'Failed to access camera/microphone';
                isCallActive = false;
                return;
            }

            incomingCallAlert.style.display = 'none';
            callStatus.textContent = `Connecting with ${callerCallId}...`;
            remoteLoading.classList.add('active');

            try {
                await createPeerConnection();

                const user = auth.currentUser;
                const callDocId = incomingCallAlert.dataset.callDocId;
                console.log('Attempting to accept call with doc ID:', callDocId);

                const callDocRef = db.collection('users').doc(user.uid).collection('calls').doc(callDocId);
                const callDocSnap = await retryFirestoreOperation(() => callDocRef.get());

                if (!callDocSnap.exists) {
                    console.error('Call document not found:', callDocId);
                    callStatus.textContent = 'Call no longer exists';
                    await retryFirestoreOperation(() => callDocRef.delete());
                    remoteLoading.classList.remove('active');
                    isCallActive = false;
                    return;
                }

                const callData = callDocSnap.data();
                console.log('Call data retrieved:', callData);

                callDoc = db.collection('calls').doc(callData.callId);
                const offerCandidates = callDoc.collection('offerCandidates');
                const answerCandidates = callDoc.collection('answerCandidates');

                await retryFirestoreOperation(() =>
                    db.runTransaction(async transaction => {
                        transaction.update(callDocRef, {
                            status: 'answered',
                            answeredAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    })
                );
                console.log('Call marked as answered');

                const callSnapshotListener = callDoc.onSnapshot(async snapshot => {
                    const data = snapshot.data();
                    console.log('Call document snapshot:', data);
                    if (!peerConnection.currentRemoteDescription && data?.offer) {
                        console.log('Processing offer SDP:', data.offer);
                        const offerDescription = new RTCSessionDescription(data.offer);
                        await peerConnection.setRemoteDescription(offerDescription);

                        const answerDescription = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answerDescription);

                        const answer = {
                            type: answerDescription.type,
                            sdp: answerDescription.sdp
                        };

                        await retryFirestoreOperation(() => callDoc.update({ answer }));
                        console.log('Answer sent to call document:', answer);

                        for (const candidate of pendingIceCandidates) {
                            await peerConnection.addIceCandidate(candidate).catch(error => {
                                console.error('Error applying ICE candidate:', error);
                            });
                        }
                        pendingIceCandidates = [];

                        callStatus.textContent = `Connected with ${callerCallId}`;
                        remoteLoading.classList.remove('active');
                        endCallBtn.style.display = 'block';

                        await retryFirestoreOperation(() => callDocRef.delete());
                        console.log('Call notification deleted after connection');
                    }
                    if (data?.status === 'ended') {
                        console.log('Call ended by other party');
                        remoteLoading.classList.remove('active');
                        endCall();
                    }
                }, error => {
                    console.error('Call snapshot listener error:', error);
                    callStatus.textContent = 'Error in call connection: ' + error.message;
                    remoteLoading.classList.remove('active');
                });
                callListeners.push(callSnapshotListener);

                const offerCandidatesListener = offerCandidates.onSnapshot(snapshot => {
                    snapshot.docChanges().forEach(async change => {
                        if (change.type === 'added') {
                            const candidate = new RTCIceCandidate(change.doc.data());
                            console.log('Received offer candidate:', candidate);
                            if (peerConnection.currentRemoteDescription) {
                                await peerConnection.addIceCandidate(candidate).catch(error => {
                                    console.error('Error adding ICE candidate:', error);
                                });
                            } else {
                                pendingIceCandidates.push(candidate);
                                console.log('Buffered ICE candidate:', candidate);
                            }
                        }
                    });
                }, error => {
                    console.error('Offer candidates listener error:', error);
                });
                callListeners.push(offerCandidatesListener);

                peerConnection.onicecandidate = async event => {
                    if (event.candidate) {
                        console.log('Sending answer ICE candidate:', event.candidate);
                        await retryFirestoreOperation(() =>
                            answerCandidates.add(event.candidate.toJSON())
                        );
                    }
                };
            } catch (error) {
                console.error('Error accepting call:', error);
                callStatus.textContent = 'Error accepting call: ' + error.message;
                remoteLoading.classList.remove('active');
                await resetCallState();
                isCallActive = false;
            }
        }

        async function rejectCall() {
            incomingCallAlert.style.display = 'none';
            callStatus.textContent = 'Call rejected';
            setTimeout(() => callStatus.textContent = '', 3000);

            try {
                const user = auth.currentUser;
                const callDocId = incomingCallAlert.dataset.callDocId;
                console.log('Rejecting call with doc ID:', callDocId);

                const callDocRef = db.collection('users').doc(user.uid).collection('calls').doc(callDocId);
                await retryFirestoreOperation(() => callDocRef.delete());
                console.log('Call notification deleted');

                if (callerCallId && callDoc) {
                    const callerCallIdDoc = await retryFirestoreOperation(() =>
                        db.collection('callIds').doc(callerCallId).get()
                    );
                    if (callerCallIdDoc.exists) {
                        const callerUid = callerCallIdDoc.data().uid;
                        await retryFirestoreOperation(() =>
                            db.collection('users').doc(callerUid).collection('calls').doc(callDoc.id).delete()
                        );
                        console.log('Caller’s call notification deleted');
                    }
                }
            } catch (error) {
                console.error('Error rejecting call:', error);
                callStatus.textContent = 'Error rejecting call: ' + error.message;
            }

            await resetCallState();
            isCallActive = false;
        }

        async function endCall() {
            console.log('Ending call, isCaller:', isCaller);
            isCallActive = false;

            if (peerConnection) {
                try {
                    peerConnection.close();
                } catch (e) {
                    console.error('Error closing peerConnection:', e);
                }
                peerConnection = null;
                console.log('PeerConnection closed');
            }
            if (remoteStream) {
                remoteStream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Stopped remote track:', track.kind);
                });
                remoteStream = null;
                console.log('Remote stream stopped');
            }

            try {
                const user = auth.currentUser;
                if (callDoc) {
                    const offerCandidates = callDoc.collection('offerCandidates');
                    const answerCandidates = callDoc.collection('answerCandidates');
                    const [offerSnapshot, answerSnapshot] = await Promise.all([
                        retryFirestoreOperation(() => offerCandidates.get()),
                        retryFirestoreOperation(() => answerCandidates.get())
                    ]);
                    await Promise.all([
                        ...offerSnapshot.docs.map(doc => retryFirestoreOperation(() => doc.ref.delete())),
                        ...answerSnapshot.docs.map(doc => retryFirestoreOperation(() => doc.ref.delete()))
                    ]);
                    console.log('Offer and answer candidates deleted');

                    await retryFirestoreOperation(() =>
                        callDoc.update({ status: 'ended', endedAt: firebase.firestore.FieldValue.serverTimestamp() })
                    );
                    await retryFirestoreOperation(() => callDoc.delete());
                    console.log('Call document deleted:', callDoc.id);
                }

                if (isCaller && targetCallId && callDoc) {
                    const targetCallIdDoc = await retryFirestoreOperation(() =>
                        db.collection('callIds').doc(targetCallId).get()
                    );
                    if (targetCallIdDoc.exists) {
                        const targetUid = targetCallIdDoc.data().uid;
                        await retryFirestoreOperation(() =>
                            db.collection('users').doc(targetUid).collection('calls').doc(callDoc.id).update({
                                status: 'ended',
                                refreshRequired: true,
                                endedAt: firebase.firestore.FieldValue.serverTimestamp()
                            })
                        );
                        console.log('Target user notified to refresh');
                        await retryFirestoreOperation(() =>
                            db.collection('users').doc(targetUid).collection('calls').doc(callDoc.id).delete()
                        );
                        console.log('Target user’s call notification deleted');
                    }
                    await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).collection('calls').doc(callDoc.id).update({
                            status: 'ended',
                            refreshRequired: true,
                            endedAt: firebase.firestore.FieldValue.serverTimestamp()
                        })
                    );
                    await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).collection('calls').doc(callDoc.id).delete()
                    );
                    console.log('Caller’s call notification deleted');
                } else if (callerCallId && callDoc) {
                    const callerCallIdDoc = await retryFirestoreOperation(() =>
                        db.collection('callIds').doc(callerCallId).get()
                    );
                    if (callerCallIdDoc.exists) {
                        const callerUid = callerCallIdDoc.data().uid;
                        await retryFirestoreOperation(() =>
                            db.collection('users').doc(callerUid).collection('calls').doc(callDoc.id).update({
                                status: 'ended',
                                refreshRequired: true,
                                endedAt: firebase.firestore.FieldValue.serverTimestamp()
                            })
                        );
                        console.log('Caller notified to refresh');
                        await retryFirestoreOperation(() =>
                            db.collection('users').doc(callerUid).collection('calls').doc(callDoc.id).delete()
                        );
                        console.log('Caller’s call notification deleted');
                    }
                    await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).collection('calls').doc(callDoc.id).update({
                            status: 'ended',
                            refreshRequired: true,
                            endedAt: firebase.firestore.FieldValue.serverTimestamp()
                        })
                    );
                    await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).collection('calls').doc(callDoc.id).delete()
                    );
                    console.log('Callee’s call notification deleted');
                }

                await resetCallState();
                callStatus.textContent = 'Call ended';
                setTimeout(() => callStatus.textContent = '', 3000);

                console.log('Refreshing tab for user');
                await new Promise(resolve => setTimeout(resolve, 200));
                window.location.reload();
            } catch (error) {
                console.error('Error ending call:', error);
                callStatus.textContent = 'Error ending call: ' + error.message;
                await resetCallState();
                console.log('Refreshing tab after error');
                await new Promise(resolve => setTimeout(resolve, 200));
                window.location.reload();
            }
        }

        async function createPeerConnection() {
            console.log('Creating peerConnection');
            const mediaSuccess = await initMediaStream();
            if (!mediaSuccess || !localStream || !localStream.active) {
                callStatus.textContent = 'Cannot start call: Camera/microphone not available';
                throw new Error('Failed to initialize media stream');
            }

            const configuration = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    {
                        urls: 'turn:relay1.expressturn.com:3478',
                        username: 'efLAXE6876DKJ13QAR',
                        credential: 'Y8jbmsIFdQ8DxM0a'
                    },
                    {
                        urls: 'turn:relay1.expressturn.com:443?transport=tcp',
                        username: 'efLAXE6876DKJ13QAR',
                        credential: 'Y8jbmsIFdQ8DxM0a'
                    }
                ],
                iceTransportPolicy: 'all'
            };

            peerConnection = new RTCPeerConnection(configuration);
            remoteStream = new MediaStream();
            remoteVideo.srcObject = remoteStream;
            remotePlaceholder.style.display = 'none';
            remoteVideo.style.display = 'block';
            remoteVideo.classList.add('active');

            console.log('Local stream tracks before adding:', localStream.getTracks().map(t => ({
                kind: t.kind,
                enabled: t.enabled,
                readyState: t.readyState
            })));
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
                console.log('Added track to peerConnection:', track.kind, 'Enabled:', track.enabled, 'ReadyState:', track.readyState);
            });

            peerConnection.ontrack = event => {
                console.log('ontrack event:', {
                    streams: event.streams.length,
                    track: { kind: event.track.kind, enabled: event.track.enabled, readyState: event.track.readyState }
                });
                if (event.streams[0]) {
                    event.streams[0].getTracks().forEach(track => {
                        remoteStream.addTrack(track);
                        console.log('Added remote track:', track.kind, 'Enabled:', track.enabled, 'ReadyState:', track.readyState);
                    });
                    remoteVideo.srcObject = remoteStream;
                    remotePlaceholder.style.display = 'none';
                    remoteVideo.style.display = 'block';
                    remoteVideo.classList.add('active');
                    remoteLoading.classList.remove('active');
                    const videoTracks = remoteStream.getVideoTracks();
                    const audioTracks = remoteStream.getAudioTracks();
                    console.log('Remote stream tracks:', { video: videoTracks.length, audio: audioTracks.length });
                    if (videoTracks.length === 0) {
                        callStatus.textContent = 'No remote video stream received';
                        setTimeout(() => callStatus.textContent = '', 5000);
                    }
                    if (audioTracks.length === 0) {
                        callStatus.textContent = 'No remote audio stream received';
                        setTimeout(() => callStatus.textContent = '', 5000);
                    }
                } else {
                    console.warn('No streams in ontrack event');
                    callStatus.textContent = 'No remote streams received';
                    setTimeout(() => callStatus.textContent = '', 5000);
                }
            };

            peerConnection.onconnectionstatechange = async () => {
                console.log('Connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'disconnected' || 
                    peerConnection.connectionState === 'failed') {
                    console.log('Connection failed or disconnected, ending call');
                    callStatus.textContent = 'Connection lost';
                    remoteLoading.classList.remove('active');
                    endCall();
                }
            };

            peerConnection.oniceconnectionstatechange = async () => {
                console.log('ICE connection state:', peerConnection.iceConnectionState);
                if (peerConnection.iceConnectionState === 'failed') {
                    console.log('ICE connection failed, ending call');
                    callStatus.textContent = 'ICE connection failed';
                    remoteLoading.classList.remove('active');
                    endCall();
                }
            };
        }

        function toggleCamera() {
            if (!localStream) {
                console.log('Cannot toggle camera: Local stream not available');
                callStatus.textContent = 'Camera not available';
                return;
            }
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('toggleCam').textContent = 
                    videoTrack.enabled ? 'Camera Off' : 'Camera On';
                console.log('Camera toggled:', videoTrack.enabled ? 'On' : 'Off');
            }
        }

        function toggleMic() {
            if (!localStream) {
                console.log('Cannot toggle mic: Local stream not available');
                callStatus.textContent = 'Microphone not available';
                return;
            }
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('toggleMic').textContent = 
                    audioTrack.enabled ? 'Mic Off' : 'Mic On';
                console.log('Microphone toggled:', audioTrack.enabled ? 'On' : 'Off');
            }
        }

        auth.onAuthStateChanged(async user => {
            console.log('Auth state changed:', user ? `User logged in: ${user.uid}` : 'No user');
            if (user) {
                console.log('Checking user data in Firestore...');
                try {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const userDoc = await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).get()
                    );
                    console.log('Firestore query completed, exists:', userDoc.exists, 'data:', userDoc.data());

                    if (userDoc.exists && userDoc.data().callId) {
                        console.log(`CallId found: ${userDoc.data().callId}, initializing call section`);
                        myCallId = userDoc.data().callId;
                        await initCallSection();
                        showSection(callContainer);
                        authStatus.textContent = '';
                    } else {
                        console.log('No callId found, showing call ID creation');
                        showSection(callIdContainer);
                        authStatus.textContent = '';
                    }
                } catch (error) {
                    console.error('Error checking user data:', error);
                    authStatus.textContent = 'Error loading user data: ' + error.message;
                }
            } else {
                console.log('No user, showing auth section');
                await resetCallState();
                showSection(authContainer);
                authStatus.textContent = '';
            }
        });

        window.onbeforeunload = async () => {
            try {
                const user = auth.currentUser;
                if (user) {
                    await retryFirestoreOperation(() =>
                        db.collection('users').doc(user.uid).update({
                            online: false,
                            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
                        })
                    );
                }
                await resetCallState();
            } catch (error) {
                console.error('Error during cleanup:', error);
            }
        };
    </script>
</body>
</html>
